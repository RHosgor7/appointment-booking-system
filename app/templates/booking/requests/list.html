{% extends "base.html" %}

{% block content %}
<!--begin::Content container-->
<div id="kt_app_content_container" class="app-container container-xxl">
	<!--begin::Card-->
	<div class="card">
		<!--begin::Card header-->
		<div class="card-header border-0 pt-6">
			<!--begin::Card title-->
			<div class="card-title">
				<!--begin::Search-->
				<div class="d-flex align-items-center position-relative my-1">
					<i class="ki-duotone ki-magnifier fs-3 position-absolute ms-5">
						<span class="path1"></span>
						<span class="path2"></span>
					</i>
					<input type="text" id="kt_appointment_requests_table_search" class="form-control form-control-solid w-250px ps-12" placeholder="Search Appointment Requests" />
				</div>
				<!--end::Search-->
			</div>
			<!--end::Card title-->
			<!--begin::Card toolbar-->
			<div class="card-toolbar flex-row-fluid justify-content-end gap-5">
				<!--begin::Daterangepicker-->
				<input class="form-control form-control-solid w-100 mw-250px" placeholder="Pick date range" id="kt_appointment_requests_daterangepicker" />
				<!--end::Daterangepicker-->
				<!--begin::Filter Menu-->
				<div class="m-0">
					<!--begin::Menu toggle-->
					<a href="#" class="btn btn-flex btn-secondary fw-bold" data-kt-menu-trigger="click" data-kt-menu-placement="bottom-end">
						<i class="ki-duotone ki-filter fs-6 text-muted me-1">
							<span class="path1"></span>
							<span class="path2"></span>
						</i>Filter</a>
					<!--end::Menu toggle-->
					<!--begin::Menu-->
					<div class="menu menu-sub menu-sub-dropdown w-300px w-md-350px" data-kt-menu="true" id="kt_appointment_requests_filter_menu">
						<!--begin::Header-->
						<div class="px-7 py-5">
							<div class="fs-5 text-gray-900 fw-bold">Filter Options</div>
						</div>
						<!--end::Header-->
						<!--begin::Menu separator-->
						<div class="separator border-gray-200"></div>
						<!--end::Menu separator-->
						<!--begin::Form-->
						<div class="px-7 py-5">
							<!--begin::Input group - Staff-->
							<div class="mb-10">
								<label class="form-label fw-semibold">Staff:</label>
								<select class="form-select form-select-solid" id="filter_staff" multiple="multiple" data-placeholder="Select staff" data-kt-select2="true" data-dropdown-parent="#kt_appointment_requests_filter_menu">
								</select>
							</div>
							<!--end::Input group-->
							<!--begin::Input group - Customer-->
							<div class="mb-10">
								<label class="form-label fw-semibold">Customer:</label>
								<select class="form-select form-select-solid" id="filter_customer" multiple="multiple" data-placeholder="Select customer" data-kt-select2="true" data-dropdown-parent="#kt_appointment_requests_filter_menu">
								</select>
							</div>
							<!--end::Input group-->
							<!--begin::Input group - Service-->
							<div class="mb-10">
								<label class="form-label fw-semibold">Service:</label>
								<select class="form-select form-select-solid" id="filter_service" multiple="multiple" data-placeholder="Select service" data-kt-select2="true" data-dropdown-parent="#kt_appointment_requests_filter_menu">
								</select>
							</div>
							<!--end::Input group-->
							<!--begin::Input group - Status (Single Select)-->
							<div class="mb-10">
								<label class="form-label fw-semibold">Status:</label>
								<select class="form-select form-select-solid" id="filter_status" data-placeholder="Select status" data-kt-select2="true" data-dropdown-parent="#kt_appointment_requests_filter_menu" required>
									<option value="pending" selected>Pending</option>
									<option value="rejected">Rejected</option>
								</select>
							</div>
							<!--end::Input group-->
							<!--begin::Actions-->
							<div class="d-flex justify-content-end">
								<button type="button" class="btn btn-sm btn-light btn-active-light-primary me-2" id="btn_reset_filters" data-kt-menu-dismiss="true">Reset</button>
								<button type="button" class="btn btn-sm btn-primary" id="btn_apply_filters" data-kt-menu-dismiss="true">Apply</button>
							</div>
							<!--end::Actions-->
						</div>
						<!--end::Form-->
					</div>
					<!--end::Menu-->
				</div>
				<!--end::Filter Menu-->
			</div>
			<!--end::Card toolbar-->
		</div>
		<!--end::Card header-->
		<!--begin::Card body-->
		<div class="card-body pt-0">
			<!--begin::Table-->
			<table class="table align-middle table-row-dashed fs-6 gy-5" id="kt_appointment_requests_table">
				<thead>
					<tr class="text-start text-gray-500 fw-bold fs-7 text-uppercase gs-0">
						<th class="min-w-80px">ID</th>
						<th class="min-w-150px">Date & Time</th>
						<th class="min-w-125px">Customer</th>
						<th class="min-w-125px">Staff</th>
						<th class="min-w-150px">Services</th>
						<th class="min-w-100px">Status</th>
						<th class="text-end min-w-70px">Actions</th>
					</tr>
				</thead>
				<tbody class="fw-semibold text-gray-600" id="kt_appointment_requests_table_body">
					<!-- Data will be loaded here via JavaScript -->
					<tr id="kt_appointment_requests_table_loading">
						<td colspan="7" class="text-center py-10">
							<div class="spinner-border text-primary" role="status">
								<span class="visually-hidden">Loading...</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
			<!--end::Table-->
		</div>
		<!--end::Card body-->
	</div>
	<!--end::Card-->
	<!--begin::Table Info (outside card)-->
	<div class="d-flex align-items-center justify-content-between flex-wrap mt-5">
		<div class="text-gray-600 fw-semibold fs-6" id="kt_appointment_requests_table_info">
			<!-- DataTable info will be displayed here -->
		</div>
	</div>
	<!--end::Table Info-->
</div>
<!--end::Content container-->
{% endblock %}

{% block scripts %}
<script>
	"use strict";

	// Token kontrol√º
	const token = localStorage.getItem('access_token');
	if (!token) {
		window.location.href = '/login';
	}

	// API base URL
	const API_BASE = '/api/appointments';
	const CUSTOMERS_API = '/api/customers';
	const STAFF_API = '/api/staff';
	const SERVICES_API = '/api/services';

	// Filter state
	let currentDateRange = null; // { start: Date, end: Date }
	let currentFilters = {
		staff_id: [],
		customer_id: [],
		status: 'pending', // Single value: 'pending' (default), 'rejected', or null for 'All'
		service_id: []
	};

	// Race condition guard: AbortController for fetch requests
	let currentAbortController = null;
	let currentRequestId = 0;

	// DataTable instance
	let datatable = null;
	let table = null;
	let currentPageLength = 10; // Store current page length to preserve select2 value

	// Escape HTML to prevent XSS - null/number safe
	function escapeHtml(text) {
		// Convert to string safely (handles null, undefined, numbers)
		const str = String(text || '');
		if (!str) return '';
		const map = {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#039;'
		};
		return str.replace(/[&<>"']/g, m => map[m]);
	}

	// Load appointment requests function with race condition protection
	async function loadAppointmentRequests() {
		// Abort previous request if still pending
		if (currentAbortController) {
			currentAbortController.abort();
		}

		// Create new AbortController and request ID for this request
		currentAbortController = new AbortController();
		const signal = currentAbortController.signal;
		const requestId = ++currentRequestId;

		const tbody = document.getElementById('kt_appointment_requests_table_body');
		const loadingRow = document.getElementById('kt_appointment_requests_table_loading');
		
		if (!tbody) {
			console.warn('kt_appointment_requests_table_body element not found');
			return;
		}

		try {
			// Build query parameters with filters
			const params = new URLSearchParams();
			params.append('include_services', 'true');
			params.append('include_names', 'true');
			
			// Status filter: pending or rejected (always required, default to pending)
			const statusFilter = currentFilters.status || 'pending';
			params.append('status', statusFilter);
			
			// Date range filters
			if (currentDateRange && currentDateRange.start && currentDateRange.end) {
				// Use local date components to avoid timezone issues
				const startYear = currentDateRange.start.getFullYear();
				const startMonth = String(currentDateRange.start.getMonth() + 1).padStart(2, '0');
				const startDay = String(currentDateRange.start.getDate()).padStart(2, '0');
				params.append('start_date', `${startYear}-${startMonth}-${startDay}`);
				
				// API uses DATE(a.appointment_date) < %s, so we need to add 1 day to include the end date
				const endDate = new Date(currentDateRange.end);
				endDate.setDate(endDate.getDate() + 1);
				const endYear = endDate.getFullYear();
				const endMonth = String(endDate.getMonth() + 1).padStart(2, '0');
				const endDay = String(endDate.getDate()).padStart(2, '0');
				params.append('end_date', `${endYear}-${endMonth}-${endDay}`);
			}
			
			// Filter parameters
			if (currentFilters.staff_id && currentFilters.staff_id.length > 0) {
				currentFilters.staff_id.forEach(staffId => params.append('staff_id', staffId));
			}
			if (currentFilters.customer_id && currentFilters.customer_id.length > 0) {
				currentFilters.customer_id.forEach(customerId => params.append('customer_id', customerId));
			}
			if (currentFilters.service_id && currentFilters.service_id.length > 0) {
				currentFilters.service_id.forEach(serviceId => params.append('service_id', serviceId));
			}
			
			// include_services=true ile servis bilgilerini de al
			const response = await fetch(`${API_BASE}?${params.toString()}`, {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${token}`,
					'Content-Type': 'application/json'
				},
				signal: signal
			});

			// Check if request was aborted
			if (signal.aborted) {
				return;
			}

			if (!response.ok) {
				if (response.status === 401) {
					localStorage.removeItem('access_token');
					window.location.href = '/login';
					return;
				}
				throw new Error(`HTTP error! status: ${response.status}`);
			}

			const appointments = await response.json();

			// Check again if request was aborted or if this is not the latest request
			if (signal.aborted || requestId !== currentRequestId) {
				console.log('Request aborted or superseded, ignoring response');
				return;
			}
			
			// Remove loading row
			if (loadingRow) {
				loadingRow.remove();
			}

			// Clear tbody
			tbody.innerHTML = '';

			// Final check before rendering (double-check race condition)
			if (signal.aborted || requestId !== currentRequestId) {
				console.log('Request aborted before rendering, ignoring response');
				return;
			}

			if (appointments.length === 0) {
				// Destroy DataTable if exists - preserve page length
				if (datatable) {
					try {
						const pageInfo = datatable.page.info();
						currentPageLength = pageInfo.length;
					} catch (e) {
						// If page info is not available, keep current value
					}
					datatable.destroy();
					datatable = null;
				}
				
				// Clear tbody completely - let DataTables handle empty state
				tbody.innerHTML = '';
				
				// Initialize DataTable with empty data - DataTables will show its own empty message
				if (typeof $ !== 'undefined' && $.fn.DataTable) {
					datatable = $(table).DataTable({
						"info": false,
						"order": [],
						"pageLength": currentPageLength,
						"language": {
							"emptyTable": "No appointment requests found",
							"zeroRecords": "No matching appointment requests found"
						}
					});
					datatable.on('draw', function() {
						updateTableInfo();
					});
					// Listen for page length change to preserve it
					datatable.on('length.dt', function(e, settings, len) {
						currentPageLength = len;
					});
					updateTableInfo();
				}
				// Reinitialize Metronic menus after render
				if (typeof KTMenu !== 'undefined') {
					KTMenu.init();
				}
				return;
			}

			// Appointments are already filtered by API, use them directly
			let filteredAppointments = appointments;

			// Destroy DataTable BEFORE populating table (if it exists)
			// Preserve current page length before destroying
			if (datatable) {
				try {
					const pageInfo = datatable.page.info();
					currentPageLength = pageInfo.length; // Get current page length
				} catch (e) {
					// If page info is not available, keep current value
				}
				datatable.destroy();
				datatable = null;
			}

			// Clear tbody AFTER DataTable destroy (DataTable destroy may leave rows)
			tbody.innerHTML = '';

			// Populate table - prevent duplicate IDs
			const renderedIds = new Set();
			filteredAppointments.forEach(appointment => {
				// Skip if this appointment ID was already rendered (duplicate prevention)
				if (renderedIds.has(appointment.id)) {
					console.warn(`Duplicate appointment ID detected: ${appointment.id}, skipping`);
					return;
				}
				renderedIds.add(appointment.id);

				// Final check before rendering this row
				if (signal.aborted || requestId !== currentRequestId) {
					console.log('Request aborted during row rendering, stopping');
					return;
				}

				const row = document.createElement('tr');
				const appointmentDate = new Date(appointment.appointment_date);
				const formattedDate = appointmentDate.toLocaleDateString('en-US', {
					year: 'numeric',
					month: 'short',
					day: 'numeric'
				});
				const formattedTime = appointmentDate.toLocaleTimeString('en-US', {
					hour: '2-digit',
					minute: '2-digit'
				});

				// Status badge
				let statusBadge = '';
				switch(appointment.status) {
					case 'pending':
						statusBadge = '<span class="badge badge-light-warning">Pending</span>';
						break;
					case 'rejected':
						statusBadge = '<span class="badge badge-light-danger">Rejected</span>';
						break;
					default:
						statusBadge = '<span class="badge badge-light">' + escapeHtml(appointment.status) + '</span>';
				}

				// Services list
				let servicesHtml = '-';
				if (appointment.services && appointment.services.length > 0) {
					servicesHtml = appointment.services.map(s => escapeHtml(s.name)).join(', ');
				}

				// Actions buttons (only show Approve for pending, only Reject for rejected)
				let actionsHtml = '';
				if (appointment.status === 'pending') {
					actionsHtml = `
						<a href="/appointments/${appointment.id}" class="btn btn-sm btn-light me-2">View</a>
						<button class="btn btn-sm btn-success me-2" onclick="approveAppointment(${appointment.id})">Approve</button>
						<button class="btn btn-sm btn-danger" onclick="rejectAppointment(${appointment.id})">Reject</button>
					`;
				} else if (appointment.status === 'rejected') {
					actionsHtml = `
						<a href="/appointments/${appointment.id}" class="btn btn-sm btn-light">View</a>
					`;
				}

				row.innerHTML = `
					<td>
						<div class="text-gray-800 fw-bold">#${escapeHtml(appointment.id)}</div>
					</td>
					<td>
						<div class="text-gray-800 fw-bold">${formattedDate}</div>
						<div class="text-gray-600 fs-7">${formattedTime}</div>
					</td>
					<td>${escapeHtml(appointment.customer_full_name || 'N/A')}</td>
					<td>${escapeHtml(appointment.staff_full_name || 'N/A')}</td>
					<td>
						<div class="text-gray-800">${servicesHtml}</div>
					</td>
					<td>${statusBadge}</td>
					<td class="text-end">
						${actionsHtml}
					</td>
				`;
				tbody.appendChild(row);
			});

			// Final check before initializing DataTable
			if (signal.aborted || requestId !== currentRequestId) {
				console.log('Request aborted before DataTable init, ignoring');
				return;
			}

			// Initialize DataTable AFTER populating table
			if (typeof $ !== 'undefined' && $.fn.DataTable) {
				datatable = $(table).DataTable({
					"info": false, // We'll use custom info display
					"order": [],
					"pageLength": currentPageLength, // Use preserved page length
					"language": {
						"emptyTable": "No appointment requests found",
						"zeroRecords": "No matching appointment requests found"
					}
				});

				// Update custom info display on draw and page change
				datatable.on('draw', function() {
					updateTableInfo();
				});

				// Listen for page length change to preserve it
				datatable.on('length.dt', function(e, settings, len) {
					currentPageLength = len;
				});

				// Initial update
				updateTableInfo();
			}

			// Reinitialize Metronic menus after table render is complete
			if (typeof KTMenu !== 'undefined') {
				KTMenu.init();
				// Also try createInstances if available
				if (typeof KTMenu.createInstances === 'function') {
					KTMenu.createInstances();
				}
			}

			// Log successful render for debugging
			console.log(`Appointment requests rendered: ${filteredAppointments.length} appointments (request ID: ${requestId})`);

		} catch (error) {
			// Ignore abort errors
			if (error.name === 'AbortError') {
				return;
			}
			console.error('Error loading appointment requests:', error);
			if (loadingRow) {
				loadingRow.innerHTML = `
					<td colspan="7" class="text-center py-10">
						<div class="text-danger">Error loading appointment requests. Please try again.</div>
					</td>
				`;
			}
		} finally {
			// Clear abort controller if this was the current request
			if (currentAbortController && currentAbortController.signal === signal) {
				currentAbortController = null;
			}
		}
	}

	// Update table info display
	function updateTableInfo() {
		if (!datatable) return;
		
		const info = datatable.page.info();
		const infoElement = document.getElementById('kt_appointment_requests_table_info');
		
		if (infoElement) {
			const start = info.start + 1;
			const end = info.end;
			const total = info.recordsTotal;
			const filtered = info.recordsDisplay;
			
			if (filtered === 0) {
				infoElement.textContent = 'No appointment requests found';
			} else {
				infoElement.textContent = `Showing ${start} to ${end} of ${filtered} entries${filtered !== total ? ` (filtered from ${total} total entries)` : ''}`;
			}
		}
	}

	// Approve appointment
	async function approveAppointment(appointmentId) {
		if (typeof Swal === 'undefined') {
			if (!confirm('Approve this appointment request?')) return;
		} else {
			const result = await Swal.fire({
				text: "Approve this appointment request?",
				icon: "question",
				showCancelButton: true,
				buttonsStyling: false,
				confirmButtonText: "Yes, approve!",
				cancelButtonText: "No, cancel",
				customClass: {
					confirmButton: "btn btn-success",
					cancelButton: "btn btn-light"
				}
			});
			if (!result.isConfirmed) return;
		}

		try {
			const response = await fetch(`${API_BASE}/${appointmentId}/approve`, {
				method: 'POST',
				headers: {
					'Authorization': `Bearer ${token}`,
					'Content-Type': 'application/json'
				}
			});

			if (!response.ok) {
				if (response.status === 401) {
					localStorage.removeItem('access_token');
					window.location.href = '/login';
					return;
				}
				const errorData = await response.json();
				throw new Error(errorData.detail || 'Failed to approve appointment');
			}

			if (typeof Swal !== 'undefined') {
				Swal.fire({
					text: "Appointment approved successfully!",
					icon: "success",
					buttonsStyling: false,
					confirmButtonText: "Ok",
					customClass: {
						confirmButton: "btn btn-primary"
					}
				});
			}

			loadAppointmentRequests();
		} catch (error) {
			console.error('Error approving appointment:', error);
			if (typeof Swal !== 'undefined') {
				Swal.fire({
					text: "Error: " + error.message,
					icon: "error",
					buttonsStyling: false,
					confirmButtonText: "Ok",
					customClass: {
						confirmButton: "btn btn-primary"
					}
				});
			}
		}
	}

	// Reject appointment
	async function rejectAppointment(appointmentId) {
		if (typeof Swal === 'undefined') {
			if (!confirm('Reject this appointment request?')) return;
		} else {
			const result = await Swal.fire({
				text: "Reject this appointment request?",
				icon: "warning",
				showCancelButton: true,
				buttonsStyling: false,
				confirmButtonText: "Yes, reject!",
				cancelButtonText: "No, cancel",
				customClass: {
					confirmButton: "btn btn-danger",
					cancelButton: "btn btn-light"
				}
			});
			if (!result.isConfirmed) return;
		}

		try {
			const response = await fetch(`${API_BASE}/${appointmentId}/reject`, {
				method: 'POST',
				headers: {
					'Authorization': `Bearer ${token}`,
					'Content-Type': 'application/json'
				}
			});

			if (!response.ok) {
				if (response.status === 401) {
					localStorage.removeItem('access_token');
					window.location.href = '/login';
					return;
				}
				const errorData = await response.json();
				throw new Error(errorData.detail || 'Failed to reject appointment');
			}

			if (typeof Swal !== 'undefined') {
				Swal.fire({
					text: "Appointment rejected successfully!",
					icon: "success",
					buttonsStyling: false,
					confirmButtonText: "Ok",
					customClass: {
						confirmButton: "btn btn-primary"
					}
				});
			}

			loadAppointmentRequests();
		} catch (error) {
			console.error('Error rejecting appointment:', error);
			if (typeof Swal !== 'undefined') {
				Swal.fire({
					text: "Error: " + error.message,
					icon: "error",
					buttonsStyling: false,
					confirmButtonText: "Ok",
					customClass: {
						confirmButton: "btn btn-primary"
					}
				});
			}
		}
	}

	// Configure toastr global settings
	if (typeof toastr !== 'undefined') {
		toastr.options = {
			"closeButton": true,
			"debug": false,
			"newestOnTop": true,
			"progressBar": true,
			"positionClass": "toast-top-right",
			"preventDuplicates": false,
			"showDuration": "300",
			"hideDuration": "1000",
			"timeOut": "5000",
			"extendedTimeOut": "1000",
			"showEasing": "swing",
			"hideEasing": "linear",
			"showMethod": "fadeIn",
			"hideMethod": "fadeOut"
		};
	}

	// Load appointment requests on page load and setup event listeners
	document.addEventListener('DOMContentLoaded', function() {
		// Get table element
		table = document.querySelector('#kt_appointment_requests_table');
		
		if (!table) {
			console.warn('kt_appointment_requests_table element not found');
			return;
		}

		// Search functionality - use DataTable search
		const searchInput = document.getElementById('kt_appointment_requests_table_search');
		if (searchInput) {
			searchInput.addEventListener('keyup', function(e) {
				if (datatable) {
					datatable.search(e.target.value).draw();
					updateTableInfo();
				} else {
					// Fallback if DataTable not initialized yet
					const searchTerm = e.target.value.toLowerCase();
					const rows = document.querySelectorAll('#kt_appointment_requests_table_body tr');
					
					rows.forEach(row => {
						const text = row.textContent.toLowerCase();
						row.style.display = text.includes(searchTerm) ? '' : 'none';
					});
				}
			});
		} else {
			console.warn('kt_appointment_requests_table_search element not found');
		}

		// Initialize daterangepicker
		if (typeof moment !== 'undefined' && typeof $.fn.daterangepicker !== 'undefined') {
			const daterangepickerInput = document.getElementById('kt_appointment_requests_daterangepicker');
			if (daterangepickerInput) {
				// Default: All Time (no date range)
				currentDateRange = null;

				// Use a very wide date range for "All Time" (100 years ago to 100 years from now)
				const allTimeStart = moment().subtract(100, 'years');
				const allTimeEnd = moment().add(100, 'years');

				function cb(start, end) {
					// Check if it's "All Time" range
					if (start && end && start.isSame(allTimeStart, 'day') && end.isSame(allTimeEnd, 'day')) {
						$(daterangepickerInput).val('All Time');
						currentDateRange = null;
					} else if (start && end) {
						$(daterangepickerInput).val(start.format("MMMM D, YYYY") + " - " + end.format("MMMM D, YYYY"));
						currentDateRange = {
							start: start.toDate(),
							end: end.toDate()
						};
					} else {
						$(daterangepickerInput).val('All Time');
						currentDateRange = null;
					}
				}

				$(daterangepickerInput).daterangepicker({
					startDate: allTimeStart,
					endDate: allTimeEnd,
					autoUpdateInput: false,
					ranges: {
						"Today": [moment(), moment()],
						"Yesterday": [moment().subtract(1, "days"), moment().subtract(1, "days")],
						"Last 7 Days": [moment().subtract(6, "days"), moment()],
						"Last 30 Days": [moment().subtract(29, "days"), moment()],
						"This Month": [moment().startOf("month"), moment().endOf("month")],
						"Last Month": [moment().subtract(1, "month").startOf("month"), moment().subtract(1, "month").endOf("month")],
						"All Time": [allTimeStart, allTimeEnd]
					}
				}, cb);

				// Set initial value to "All Time"
				cb(allTimeStart, allTimeEnd);

				// Handle date range change
				$(daterangepickerInput).on('apply.daterangepicker', function(ev, picker) {
					const label = picker.chosenLabel;
					if (label === 'All Time') {
						currentDateRange = null;
						$(daterangepickerInput).val('All Time');
					} else {
						currentDateRange = {
							start: picker.startDate.toDate(),
							end: picker.endDate.toDate()
						};
						cb(picker.startDate, picker.endDate);
					}
					loadAppointmentRequests();
				});

				// Handle cancel (reset to all dates)
				$(daterangepickerInput).on('cancel.daterangepicker', function(ev, picker) {
					currentDateRange = null;
					$(daterangepickerInput).val('All Time');
					loadAppointmentRequests();
				});
			} else {
				console.warn('kt_appointment_requests_daterangepicker element not found');
			}
		} else {
			console.warn('moment.js or daterangepicker not available');
		}

		// Load filter options from API
		async function loadFilterOptions() {
			try {
				// Load Staff
				const staffResponse = await fetch(`${STAFF_API}`, {
					headers: { 'Authorization': `Bearer ${token}` }
				});
				if (staffResponse.ok) {
					const staffList = await staffResponse.json();
					const staffSelect = $('#filter_staff');
					staffList.forEach(staff => {
						staffSelect.append(new Option(staff.full_name || staff.email, staff.id, false, false));
					});
				}

				// Load Customers
				const customersResponse = await fetch(`${CUSTOMERS_API}`, {
					headers: { 'Authorization': `Bearer ${token}` }
				});
				if (customersResponse.ok) {
					const customerList = await customersResponse.json();
					const customerSelect = $('#filter_customer');
					customerList.forEach(customer => {
						customerSelect.append(new Option(customer.full_name || customer.email, customer.id, false, false));
					});
				}

				// Load Services
				const servicesResponse = await fetch(`${SERVICES_API}`, {
					headers: { 'Authorization': `Bearer ${token}` }
				});
				if (servicesResponse.ok) {
					const serviceList = await servicesResponse.json();
					const serviceSelect = $('#filter_service');
					serviceList.forEach(service => {
						serviceSelect.append(new Option(service.name, service.id, false, false));
					});
				}
			} catch (error) {
				console.error('Error loading filter options:', error);
			}
		}

		// Initialize filter Select2 dropdowns
		if (typeof $ !== 'undefined' && $.fn.select2) {
			// Initialize Select2 for filter dropdowns (multi-select for staff, customer, service)
			$('#filter_staff, #filter_customer, #filter_service').select2({
				placeholder: function() {
					return $(this).data('placeholder') || 'Select option';
				},
				allowClear: true,
				closeOnSelect: false,
				width: '100%'
			});

			// Initialize Select2 for status (single select) - cannot be empty
			$('#filter_status').select2({
				placeholder: 'Select status',
				allowClear: false, // Cannot be cleared/empty
				width: '100%',
				minimumResultsForSearch: Infinity // Disable search for this dropdown
			});

			// Set default status to "pending"
			$('#filter_status').val('pending').trigger('change');
			currentFilters.status = 'pending';

			// Load filter options
			loadFilterOptions();

			// Apply filters button
			$('#btn_apply_filters').on('click', function() {
				currentFilters.staff_id = $('#filter_staff').val() || [];
				currentFilters.customer_id = $('#filter_customer').val() || [];
				currentFilters.service_id = $('#filter_service').val() || [];
				currentFilters.status = $('#filter_status').val() || 'pending'; // Single value, default to pending if empty
				loadAppointmentRequests();
			});

			// Reset filters button
			$('#btn_reset_filters').on('click', function() {
				currentFilters = {
					staff_id: [],
					customer_id: [],
					status: 'pending', // Default to pending
					service_id: []
				};
				$('#filter_staff, #filter_customer, #filter_service').val(null).trigger('change');
				$('#filter_status').val('pending').trigger('change');
				loadAppointmentRequests();
			});
		}

		// Load appointment requests on page load
		loadAppointmentRequests();
	});
</script>
{% endblock %}
